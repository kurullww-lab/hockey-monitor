import asyncio
import logging
import json
import requests
import sqlite3
import os
from bs4 import BeautifulSoup
from datetime import datetime
from flask import Flask, request
from threading import Thread
import time
import re

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
URL = "https://hcdinamo.by/tickets/"
BOT_TOKEN = "8416784515:AAG1yGWcgm9gGFPJLodfLvEJrtmIFVJjsu8"
STATE_FILE = "matches_state.json"
CHECK_INTERVAL = 300
PING_INTERVAL = 240
ADMIN_ID = "645388044"
RENDER_URL = "https://hockey-monitor.onrender.com"

logging.basicConfig(
    level=logging.INFO, 
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt='%Y-%m-%d %H:%M:%S'
)

app = Flask(__name__)

# ========== –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ü–ê–†–°–ò–ù–ì –î–ê–¢ ==========

def parse_match_date(date_string):
    """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –∏ –Ω–∞–¥–µ–∂–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –¥–∞—Ç—ã –º–∞—Ç—á–∞"""
    try:
        logging.info(f"üîß –ü–∞—Ä—Å–∏–º –¥–∞—Ç—É: '{date_string}'")
        
        # –°–ª–æ–≤–∞—Ä–∏ –º–µ—Å—è—Ü–µ–≤
        months_ru = {
            '—è–Ω–≤–∞—Ä—è': 1, '—Ñ–µ–≤—Ä–∞–ª—è': 2, '–º–∞—Ä—Ç–∞': 3, '–∞–ø—Ä–µ–ª—è': 4, '–º–∞—è': 5, '–∏—é–Ω—è': 6,
            '–∏—é–ª—è': 7, '–∞–≤–≥—É—Å—Ç–∞': 8, '—Å–µ–Ω—Ç—è–±—Ä—è': 9, '–æ–∫—Ç—è–±—Ä—è': 10, '–Ω–æ—è–±—Ä—è': 11, '–¥–µ–∫–∞–±—Ä—è': 12
        }
        
        # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
        date_lower = date_string.lower().strip()
        
        # –†–∞–∑–±–∏—Ä–∞–µ–º —á–∞—Å—Ç–∏ –¥–∞—Ç—ã
        parts = date_string.split()
        if len(parts) < 2:
            return datetime.now()
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–µ–Ω—å –∏ –≤—Ä–µ–º—è
        day_str = parts[0].strip()
        time_str = parts[-1].strip()
        
        # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –º–µ—Å—è—Ü –≤ —Å—Ç—Ä–æ–∫–µ
        month_found = None
        for month_name, month_num in months_ru.items():
            if month_name in date_lower:
                month_found = month_num
                break
        
        # –ï—Å–ª–∏ –º–µ—Å—è—Ü –Ω–µ –Ω–∞—à–ª–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü
        if not month_found:
            month_found = datetime.now().month
        
        # –ü–∞—Ä—Å–∏–º –¥–µ–Ω—å
        try:
            day = int(day_str)
        except:
            day_match = re.search(r'(\d{1,2})', day_str)
            day = int(day_match.group(1)) if day_match else 1
        
        # –ü–∞—Ä—Å–∏–º –≤—Ä–µ–º—è
        try:
            if ':' in time_str:
                hours, minutes = map(int, time_str.split(':'))
            else:
                time_match = re.search(r'(\d{1,2}):(\d{2})', time_str)
                if time_match:
                    hours, minutes = int(time_match.group(1)), int(time_match.group(2))
                else:
                    hours, minutes = 19, 0
        except:
            hours, minutes = 19, 0
        
        # –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ì–û–î–ê - –£–ü–†–û–©–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê
        current_date = datetime.now()
        current_year = current_date.year
        
        # –ï—Å–ª–∏ –º–µ—Å—è—Ü –º–∞—Ç—á–∞ –º–µ–Ω—å—à–µ —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞, –∑–Ω–∞—á–∏—Ç —ç—Ç–æ —Å–ª–µ–¥—É—é—â–∏–π –≥–æ–¥
        # (–¥–ª—è —Å–µ–∑–æ–Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –¥–ª–∏—Ç—Å—è —Å –æ—Å–µ–Ω–∏ –¥–æ –≤–µ—Å–Ω—ã)
        if month_found < current_date.month:
            match_year = current_year + 1
        else:
            match_year = current_year
        
        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç datetime
        match_date = datetime(match_year, month_found, day, hours, minutes)
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –¥–∞—Ç–∞ –≤ –ø—Ä–æ—à–ª–æ–º (–±–æ–ª–µ–µ —á–µ–º –Ω–∞ 2 –¥–Ω—è –Ω–∞–∑–∞–¥), 
        # –∑–Ω–∞—á–∏—Ç —ç—Ç–æ —Å–ª–µ–¥—É—é—â–∏–π –≥–æ–¥
        if match_date < current_date and (current_date - match_date).days > 2:
            match_date = match_date.replace(year=match_year + 1)
            logging.info(f"üîÑ –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –≥–æ–¥ –¥–ª—è –ø—Ä–æ—à–µ–¥—à–µ–π –¥–∞—Ç—ã: {match_date}")
        
        logging.info(f"‚úÖ –î–∞—Ç–∞ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–∞: {match_date.strftime('%d.%m.%Y %H:%M')}")
        return match_date
        
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞—Ç—ã '{date_string}': {e}")
        return datetime.now()

def format_beautiful_date(date_string):
    """–ö—Ä–∞—Å–∏–≤–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã –º–∞—Ç—á–∞"""
    try:
        # –ü–∞—Ä—Å–∏–º –¥–∞—Ç—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –≥–æ–¥–∞
        parsed_date = parse_match_date(date_string)
        
        months_ru = [
            '—è–Ω–≤–∞—Ä—è', '—Ñ–µ–≤—Ä–∞–ª—è', '–º–∞—Ä—Ç–∞', '–∞–ø—Ä–µ–ª—è', '–º–∞—è', '–∏—é–Ω—è',
            '–∏—é–ª—è', '–∞–≤–≥—É—Å—Ç–∞', '—Å–µ–Ω—Ç—è–±—Ä—è', '–æ–∫—Ç—è–±—Ä—è', '–Ω–æ—è–±—Ä—è', '–¥–µ–∫–∞–±—Ä—è'
        ]
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Ä–µ–º—è –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        time_match = re.search(r'(\d{1,2}:\d{2})', date_string)
        time_str = time_match.group(1) if time_match else "19:00"
        
        day = parsed_date.day
        month_name = months_ru[parsed_date.month - 1]
        year = parsed_date.year
        
        return f"üóì {day} {month_name} {year} ‚è∞ {time_str}"
        
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞—Ç—ã '{date_string}': {e}")
        return f"üìÖ {date_string}"

# ========== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –û–¢–ü–†–ê–í–ö–ò ==========

async def test_send_to_admin():
    """–¢–µ—Å—Ç–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–¥–º–∏–Ω—É"""
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = {
            "chat_id": ADMIN_ID,
            "text": "üîî <b>–¢–ï–°–¢ –ë–û–¢–ê</b>\n\n–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç! ‚úÖ",
            "parse_mode": "HTML",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=data, timeout=10)
        if response.status_code == 200:
            logging.info("‚úÖ –¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∞–¥–º–∏–Ω—É")
            return True
        else:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–µ—Å—Ç–∞: {response.text}")
            return False
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
        return False

# ========== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –û–¢–ü–†–ê–í–ö–ê ==========

async def send_telegram_with_retry(text: str, max_retries=3):
    """–£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏ –∏ –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
    subscribers = load_subscribers()
    
    if not subscribers:
        logging.warning("‚ö†Ô∏è –ù–µ—Ç –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏")
        return
    
    logging.info(f"üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è {len(subscribers)} –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º: {subscribers}")
    
    successful_sends = 0
    failed_sends = 0
    
    for chat_id in subscribers:
        for attempt in range(max_retries):
            try:
                url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
                data = {
                    "chat_id": chat_id, 
                    "text": text, 
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                
                logging.info(f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1} –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–ª—è {chat_id}")
                response = requests.post(url, json=data, timeout=15)
                
                if response.status_code == 200:
                    logging.info(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {chat_id}")
                    successful_sends += 1
                    break
                else:
                    error_data = response.json()
                    error_msg = error_data.get('description', 'Unknown error')
                    logging.warning(f"‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries} –¥–ª—è {chat_id}: {error_msg}")
                    
                    # –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ "chat not found" –∏–ª–∏ "bot blocked", —É–¥–∞–ª—è–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞
                    if "chat not found" in error_msg.lower() or "bot was blocked" in error_msg.lower():
                        logging.warning(f"üóë –£–¥–∞–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–∞: {chat_id}")
                        remove_subscriber(chat_id)
                        break
                    
                    if attempt < max_retries - 1:
                        await asyncio.sleep(2)
                    else:
                        logging.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {chat_id} –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫")
                        failed_sends += 1
                        
            except requests.exceptions.Timeout:
                logging.warning(f"‚è∞ –¢–∞–π–º–∞—É—Ç –ø–æ–ø—ã—Ç–∫–∏ {attempt + 1} –¥–ª—è {chat_id}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(2)
                else:
                    logging.error(f"‚ùå –¢–∞–π–º–∞—É—Ç –æ—Ç–ø—Ä–∞–≤–∫–∏ {chat_id} –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫")
                    failed_sends += 1
                    
            except Exception as e:
                logging.warning(f"‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries} –¥–ª—è {chat_id}: {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(2)
                else:
                    logging.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {chat_id} –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫: {e}")
                    failed_sends += 1
    
    logging.info(f"üìä –ò—Ç–æ–≥ –æ—Ç–ø—Ä–∞–≤–∫–∏: ‚úÖ {successful_sends} —É—Å–ø–µ—à–Ω–æ, ‚ùå {failed_sends} –æ—à–∏–±–æ–∫")

# ========== –ü–†–û–í–ï–†–ö–ê –ö–û–†–†–ï–ö–¢–ù–û–°–¢–ò –î–ê–ù–ù–´–• ==========

def validate_matches(matches):
    """–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π"""
    logging.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π...")
    
    if not matches:
        logging.warning("‚ö†Ô∏è –ù–µ—Ç –º–∞—Ç—á–µ–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏")
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –¥–∞—Ç–µ –∏ –≤—Ä–µ–º–µ–Ω–∏
    date_groups = {}
    for match in matches:
        date_key = match["parsed_date"].strftime('%Y-%m-%d %H:%M')
        if date_key not in date_groups:
            date_groups[date_key] = []
        date_groups[date_key].append(match)
    
    # –ò—â–µ–º –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã
    conflicts = []
    for date_key, day_matches in date_groups.items():
        if len(day_matches) > 1:
            conflict_info = f"‚ùå –ö–æ–Ω—Ñ–ª–∏–∫—Ç –≤ {date_key}:"
            for match in day_matches:
                conflict_info += f"\n   - {match['title']}"
            conflicts.append(conflict_info)
            logging.error(conflict_info)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ–¥—ã –º–∞—Ç—á–µ–π
    current_year = datetime.now().year
    future_matches = [m for m in matches if m["parsed_date"].year > current_year + 1]
    if future_matches:
        logging.warning(f"‚ö†Ô∏è –ù–∞–π–¥–µ–Ω—ã –º–∞—Ç—á–∏ —Å –≥–æ–¥–æ–º > {current_year + 1}")
        for match in future_matches[:3]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3
            logging.warning(f"   - {match['parsed_date'].year}: {match['title']}")
    
    if conflicts:
        logging.error(f"üö® –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏: {len(conflicts)}")
        return False
    
    logging.info("‚úÖ –î–∞–Ω–Ω—ã–µ –º–∞—Ç—á–µ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã")
    return True

# ========== –û–°–¢–ê–õ–¨–ù–û–ô –ö–û–î ==========

def setup_webhook():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook –¥–ª—è Telegram"""
    try:
        webhook_url = f"{RENDER_URL}/webhook"
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/setWebhook?url={webhook_url}"
        response = requests.get(url, timeout=10)
        
        if response.status_code == 200:
            logging.info(f"‚úÖ Webhook –Ω–∞—Å—Ç—Ä–æ–µ–Ω: {webhook_url}")
            return True
        else:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook: {response.text}")
            return False
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook: {e}")
        return False

async def check_bot_status():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –±–æ—Ç–∞ –∏ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"""
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/getMe"
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            bot_info = response.json()['result']
            logging.info(f"‚úÖ –ë–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω: {bot_info['username']} ({bot_info['first_name']})")
        else:
            logging.error(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω –±–æ—Ç–∞: {response.text}")
            return False
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–æ—Ç–∞: {e}")
        return False
    
    subscribers = load_subscribers()
    logging.info(f"üë• –í—Å–µ–≥–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {len(subscribers)}")
    for sub in subscribers:
        logging.info(f"   - {sub} {'(ADMIN)' if sub == ADMIN_ID else ''}")
    
    return True

def create_beautiful_message(match):
    """–°–æ–∑–¥–∞–Ω–∏–µ –∫—Ä–∞—Å–∏–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –º–∞—Ç—á–µ"""
    beautiful_date = format_beautiful_date(match["date"])
    
    title = match['title']
    if ' ‚Äî ' in title:
        home_team, away_team = title.split(' ‚Äî ')
        formatted_title = f"üèí {home_team} vs {away_team}"
        
        if '–î–∏–Ω–∞–º–æ-–ú–∏–Ω—Å–∫' in title:
            if title.startswith('–î–∏–Ω–∞–º–æ-–ú–∏–Ω—Å–∫'):
                match_type = "üè† –î–æ–º–∞—à–Ω–∏–π –º–∞—Ç—á"
            else:
                match_type = "‚úàÔ∏è –í—ã–µ–∑–¥–Ω–æ–π –º–∞—Ç—á"
        else:
            match_type = "üèí –•–æ–∫–∫–µ–π–Ω—ã–π –º–∞—Ç—á"
    else:
        formatted_title = f"üèí {title}"
        match_type = "üèí –•–æ–∫–∫–µ–π–Ω—ã–π –º–∞—Ç—á"
    
    message = (
        "üîî <b>–ù–û–í–´–ô –ú–ê–¢–ß –í –ü–†–û–î–ê–ñ–ï!</b>\n\n"
        f"{formatted_title}\n"
        f"{match_type}\n"
        f"{beautiful_date}\n\n"
        f"üéü <a href='{match['url']}'>–ö—É–ø–∏—Ç—å –±–∏–ª–µ—Ç—ã</a>\n\n"
        "‚ö°Ô∏è <i>–£—Å–ø–µ–π –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –ª—É—á—à–∏–µ –º–µ—Å—Ç–∞!</i>"
    )
    return message

def create_removed_message(match):
    """–°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± —É–¥–∞–ª–µ–Ω–Ω–æ–º –º–∞—Ç—á–µ"""
    beautiful_date = format_beautiful_date(match["date"])
    
    title = match['title']
    if ' ‚Äî ' in title:
        home_team, away_team = title.split(' ‚Äî ')
        formatted_title = f"üèí {home_team} vs {away_team}"
    else:
        formatted_title = f"üèí {title}"
    
    message = (
        "‚ùå <b>–ú–ê–¢–ß –£–î–ê–õ–ï–ù –ò–ó –ü–†–û–î–ê–ñ–ò!</b>\n\n"
        f"{formatted_title}\n"
        f"{beautiful_date}\n\n"
        "üòî <i>–ë–∏–ª–µ—Ç—ã –±–æ–ª—å—à–µ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã</i>"
    )
    return message

def start_ping_service():
    def ping_loop():
        while True:
            try:
                response = requests.get(f"{RENDER_URL}/health", timeout=10)
                logging.info(f"üèì –ê–≤—Ç–æ-–ø–∏–Ω–≥: {response.status_code}")
            except Exception as e:
                logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ-–ø–∏–Ω–≥–∞: {e}")
            time.sleep(PING_INTERVAL)
    
    ping_thread = Thread(target=ping_loop, daemon=True)
    ping_thread.start()
    logging.info("üîî –°–ª—É–∂–±–∞ –∞–≤—Ç–æ-–ø–∏–Ω–≥–∞ –∑–∞–ø—É—â–µ–Ω–∞")

@app.route('/')
def home():
    return "üèí Hockey Monitor Bot is running!"

@app.route('/health')
def health():
    return {"status": "running", "timestamp": datetime.now().isoformat()}

@app.route('/debug')
def debug():
    subscribers = load_subscribers()
    
    html = f"""
    <html>
        <head><title>Debug Info</title><meta charset="utf-8"></head>
        <body>
            <h1>üèí Debug Information</h1>
            <h2>üë• –ü–æ–¥–ø–∏—Å—á–∏–∫–∏ ({len(subscribers)}):</h2>
            <ul>
    """
    
    for sub in subscribers:
        html += f"<li><b>{sub}</b> {'(ADMIN)' if sub == ADMIN_ID else ''}</li>"
    
    html += f"""
            </ul>
            <p><b>ADMIN_ID:</b> {ADMIN_ID}</p>
            <hr>
            <p><a href="/test_send_all">üì§ –¢–µ—Å—Ç–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤—Å–µ–º</a></p>
            <p><a href="/test_admin">üß™ –¢–µ—Å—Ç –∞–¥–º–∏–Ω—É</a></p>
            <p><a href="/setup_webhook">üîÑ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å Webhook</a></p>
            <p><a href="/check_bot">üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–æ—Ç–∞</a></p>
        </body>
    </html>
    """
    
    return html

@app.route('/test_send_all')
def test_send_all():
    """–¢–µ—Å—Ç–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤—Å–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º"""
    subscribers = load_subscribers()
    results = []
    
    for chat_id in subscribers:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": "üîî <b>–¢–ï–°–¢–û–í–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n–≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞! ‚úÖ",
            "parse_mode": "HTML",
            "disable_web_page_preview": True
        }
        try:
            response = requests.post(url, json=data, timeout=10)
            if response.status_code == 200:
                results.append(f"‚úÖ {chat_id}: –£—Å–ø–µ—à–Ω–æ")
            else:
                error_msg = response.json().get('description', 'Unknown error')
                results.append(f"‚ùå {chat_id}: –û—à–∏–±–∫–∞ {response.status_code} - {error_msg}")
        except Exception as e:
            results.append(f"‚ùå {chat_id}: –ò—Å–∫–ª—é—á–µ–Ω–∏–µ - {e}")
    
    return "<br>".join(results)

@app.route('/test_admin')
def test_admin():
    """–¢–µ—Å—Ç–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É"""
    def send_test():
        asyncio.run(test_send_to_admin())
    
    thread = Thread(target=send_test)
    thread.start()
    
    return "üß™ –¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω—É... <a href='/debug'>–ù–∞–∑–∞–¥</a>"

@app.route('/setup_webhook')
def setup_webhook_route():
    if setup_webhook():
        return "‚úÖ Webhook –Ω–∞—Å—Ç—Ä–æ–µ–Ω —É—Å–ø–µ—à–Ω–æ! <a href='/debug'>–ù–∞–∑–∞–¥</a>"
    else:
        return "‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook! <a href='/debug'>–ù–∞–∑–∞–¥</a>"

@app.route('/check_bot')
def check_bot_route():
    def check():
        asyncio.run(check_bot_status())
    
    thread = Thread(target=check)
    thread.start()
    
    return "üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–æ—Ç–∞ –∑–∞–ø—É—â–µ–Ω–∞, —Å–º–æ—Ç—Ä–∏—Ç–µ –ª–æ–≥–∏. <a href='/debug'>–ù–∞–∑–∞–¥</a>"

@app.route('/add_subscriber/<chat_id>')
def add_sub_manual(chat_id):
    if add_subscriber(chat_id, "manual"):
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": "‚úÖ –í—ã –±—ã–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ —Å–ø–∏—Å–æ–∫ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ Hockey Monitor!",
            "parse_mode": "HTML"
        }
        try:
            requests.post(url, json=data, timeout=10)
        except:
            pass
            
        return f"‚úÖ –ü–æ–¥–ø–∏—Å—á–∏–∫ {chat_id} –¥–æ–±–∞–≤–ª–µ–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ. <a href='/debug'>–ù–∞–∑–∞–¥</a>"
    return f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è {chat_id}"

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        data = request.get_json()
        logging.info(f"üì® –ü–æ–ª—É—á–µ–Ω webhook: {json.dumps(data, ensure_ascii=False)}")
        
        if 'message' in data:
            chat_id = str(data['message']['chat']['id'])
            text = data['message'].get('text', '')
            username = data['message']['chat'].get('username', '')
            first_name = data['message']['chat'].get('first_name', '')
            
            logging.info(f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {chat_id} ({username}): {text}")
            
            if text == '/start':
                if add_subscriber(chat_id, username or first_name):
                    send_telegram_sync(chat_id, 
                        f"‚úÖ –ü—Ä–∏–≤–µ—Ç, {first_name}!\n\n"
                        "–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ö–æ–∫–∫–µ–π–Ω—ã—Ö –º–∞—Ç—á–∞—Ö!\n\n"
                        "–Ø –±—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–æ–≥–¥–∞ –ø–æ—è–≤—è—Ç—Å—è –Ω–æ–≤—ã–µ –º–∞—Ç—á–∏ –≤ –ø—Ä–æ–¥–∞–∂–µ –Ω–∞ hcdinamo.by"
                    )
                    logging.info(f"üë§ –ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫: {chat_id} ({username})")
                else:
                    send_telegram_sync(chat_id, "‚ÑπÔ∏è –í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
                    
            elif text == '/stop':
                if remove_subscriber(chat_id):
                    send_telegram_sync(chat_id, "‚ùå –í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
                else:
                    send_telegram_sync(chat_id, "‚ÑπÔ∏è –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
                    
            elif text == '/status':
                subscribers = load_subscribers()
                if chat_id in subscribers:
                    send_telegram_sync(chat_id, "‚úÖ –í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
                else:
                    send_telegram_sync(chat_id, "‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
                    
            elif text == '/debug':
                subscribers = load_subscribers()
                status = "‚úÖ –ø–æ–¥–ø–∏—Å–∞–Ω" if chat_id in subscribers else "‚ùå –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω"
                send_telegram_sync(chat_id, 
                    f"üîç –í–∞—à–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:\n"
                    f"ID: {chat_id}\n"
                    f"–°—Ç–∞—Ç—É—Å: {status}\n"
                    f"–í—Å–µ–≥–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {len(subscribers)}"
                )
            else:
                send_telegram_sync(chat_id, 
                    "ü§ñ –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞:\n"
                    "/start - –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n"
                    "/stop - –û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π\n" 
                    "/status - –°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏\n"
                    "/debug - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ"
                )
        
        return 'OK'
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ webhook: {e}")
        return 'ERROR'

def send_telegram_sync(chat_id, text):
    try:
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": text,
            "parse_mode": "HTML",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=data, timeout=10)
        if response.status_code == 200:
            logging.info(f"‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω {chat_id}")
        else:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞ {chat_id}: {response.text}")
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞ {chat_id}: {e}")

def init_db():
    conn = sqlite3.connect('subscribers.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS subscribers (chat_id TEXT PRIMARY KEY, username TEXT)''')
    conn.commit()
    conn.close()

def load_subscribers():
    try:
        conn = sqlite3.connect('subscribers.db')
        c = conn.cursor()
        c.execute("SELECT chat_id FROM subscribers")
        subscribers = [row[0] for row in c.fetchall()]
        conn.close()
        return subscribers
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {e}")
        return []

def add_subscriber(chat_id, username=""):
    try:
        conn = sqlite3.connect('subscribers.db')
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO subscribers (chat_id, username) VALUES (?, ?)", 
                 (chat_id, username))
        conn.commit()
        conn.close()
        logging.info(f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –ø–æ–¥–ø–∏—Å—á–∏–∫: {chat_id} ({username})")
        return True
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å—á–∏–∫–∞: {e}")
        return False

def remove_subscriber(chat_id):
    try:
        conn = sqlite3.connect('subscribers.db')
        c = conn.cursor()
        c.execute("DELETE FROM subscribers WHERE chat_id = ?", (chat_id,))
        conn.commit()
        conn.close()
        logging.info(f"‚úÖ –£–¥–∞–ª–µ–Ω –ø–æ–¥–ø–∏—Å—á–∏–∫: {chat_id}")
        return True
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å—á–∏–∫–∞: {e}")
        return False

async def fetch_matches():
    try:
        logging.info("üåç –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ –º–∞—Ç—á–∏...")
        response = requests.get(URL, timeout=30, headers={
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        response.raise_for_status()
        
        soup = BeautifulSoup(response.text, "html.parser")
        matches = []
        for item in soup.select("a.match-item"):
            title = item.select_one("div.match-title")
            date = item.select_one("div.match-day")
            time = item.select_one("div.match-times")
            if title and date and time:
                href = item.get("href", URL)
                if href.startswith("/"):
                    href = "https://hcdinamo.by" + href
                
                match_data = {
                    "title": title.text.strip(),
                    "date": f"{date.text.strip()} {time.text.strip()}",
                    "url": href
                }
                
                match_data["parsed_date"] = parse_match_date(match_data["date"])
                matches.append(match_data)
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∞—Ç–µ
        matches.sort(key=lambda x: x["parsed_date"])
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
        validate_matches(matches)
        
        logging.info(f"üéØ –ù–∞–π–¥–µ–Ω–æ –º–∞—Ç—á–µ–π: {len(matches)}")
        for match in matches:
            logging.info(f"   - {match['parsed_date'].strftime('%d.%m.%Y %H:%M')}: {match['title']}")
        
        return matches
        
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
        return []

async def monitor():
    logging.info("üöÄ –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞")
    init_db()
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º webhook
    setup_webhook()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞
    await check_bot_status()
    
    # –¢–µ—Å—Ç–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –∞–¥–º–∏–Ω—É
    await test_send_to_admin()
    
    if ADMIN_ID not in load_subscribers():
        add_subscriber(ADMIN_ID, "admin")
        logging.info(f"‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–ø–∏—Å–∞–Ω –∞–¥–º–∏–Ω: {ADMIN_ID}")
    
    subscribers = load_subscribers()
    logging.info(f"üë• –¢–µ–∫—É—â–∏–µ –ø–æ–¥–ø–∏—Å—á–∏–∫–∏: {subscribers}")
    
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            old_matches = json.load(f)
    except:
        old_matches = []
    
    logging.info(f"üìÇ –ó–∞–≥—Ä—É–∂–µ–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –º–∞—Ç—á–µ–π: {len(old_matches)}")
    
    start_ping_service()
    
    while True:
        try:
            new_matches = await fetch_matches()
            if new_matches:
                old_titles = {m["title"] for m in old_matches}
                new_titles = {m["title"] for m in new_matches}
                
                added = new_titles - old_titles
                removed = old_titles - new_titles
                
                if added or removed:
                    logging.info(f"‚ú® –ò–∑–º–µ–Ω–µ–Ω–∏—è: +{len(added)}, -{len(removed)}")
                    
                    # –°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –º–∞—Ç—á–∞—Ö
                    for match in new_matches:
                        if match["title"] in added:
                            msg = create_beautiful_message(match)
                            logging.info(f"üì® –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {match['title']}")
                            await send_telegram_with_retry(msg)
                            await asyncio.sleep(2)  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–∞—É–∑—É –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                    
                    # –ó–∞—Ç–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –º–∞—Ç—á–∞—Ö
                    for match in old_matches:
                        if match["title"] in removed:
                            msg = create_removed_message(match)
                            logging.info(f"üì® –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± —É–¥–∞–ª–µ–Ω–∏–∏: {match['title']}")
                            await send_telegram_with_retry(msg)
                            await asyncio.sleep(2)
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–µ –º–∞—Ç—á–∏
                    try:
                        with open(STATE_FILE, "w", encoding="utf-8") as f:
                            save_matches = [{"title": m["title"], "date": m["date"], "url": m["url"]} 
                                          for m in new_matches]
                            json.dump(save_matches, f, ensure_ascii=False, indent=2)
                            logging.info("üíæ –°–æ—Å—Ç–æ—è–Ω–∏–µ –º–∞—Ç—á–µ–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
                    except Exception as e:
                        logging.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
                    
                    old_matches = new_matches
                else:
                    logging.info("‚úÖ –ò–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ—Ç")
            
            await asyncio.sleep(CHECK_INTERVAL)
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}")
            await asyncio.sleep(60)

def run_web_server():
    logging.info("üåê –ó–∞–ø—É—Å–∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É 5000...")
    app.run(host='0.0.0.0', port=5000, debug=False)

def main():
    web_thread = Thread(target=run_web_server, daemon=True)
    web_thread.start()
    
    time.sleep(3)
    logging.info("üåê –í–µ–±-—Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 5000")
    
    asyncio.run(monitor())

if __name__ == "__main__":
    main()
